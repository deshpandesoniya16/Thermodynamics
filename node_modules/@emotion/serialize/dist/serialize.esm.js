import hashString from '@emotion/hash';
import unitless from '@emotion/unitless';
import memoize from '@emotion/memoize';

var hyphenateRegex = /[A-Z]|^ms/g;
var processStyleName = memoize(function (styleName) {
  return styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});
var processStyleValue = function processStyleValue(key, value) {
  if (value == null || typeof value === 'boolean') {
    return '';
  }

  if (unitless[key] !== 1 && key.charCodeAt(1) !== 45 && // custom properties
  !isNaN(value) && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (process.env.NODE_ENV !== 'production') {
  var contentValuePattern = /(attr|calc|counters?|url)\(/;
  var contentValues = ['normal', 'none', 'counter', 'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote', 'initial', 'inherit', 'unset'];
  var oldProcessStyleValue = processStyleValue;

  processStyleValue = function processStyleValue(key, value) {
    if (key === 'content') {
      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        console.error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }

    return oldProcessStyleValue(key, value);
  };
}

function handleInterpolation(registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if (interpolation.toString() === 'NO_COMPONENT_SELECTOR' && process.env.NODE_ENV !== 'production') {
      throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
    }

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.type === 2) {
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          return interpolation.styles;
        }

        return createStringFromObject.call(this, registered, interpolation);
      }

    case 'function':
      {
        if (this !== undefined) {
          return handleInterpolation.call(this, registered, // $FlowFixMe
          interpolation(this));
        }
      }
    // eslint-disable-next-line no-fallthrough

    default:
      {
        var cached = registered[interpolation];
        return cached !== undefined ? cached : interpolation;
      }
  }
}

function createStringFromObject(registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    obj.forEach(function (interpolation) {
      string += handleInterpolation.call(this, registered, interpolation);
    }, this);
  } else {
    Object.keys(obj).forEach(function (key) {
      if (typeof obj[key] !== 'object') {
        string += processStyleName(key) + ":" + processStyleValue(key, obj[key]) + ";";
      } else {
        if (key === 'NO_COMPONENT_SELECTOR' && process.env.NODE_ENV !== 'production') {
          throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin-core.');
        }

        if (Array.isArray(obj[key]) && typeof obj[key][0] === 'string' && registered[obj[key][0]] === undefined) {
          obj[key].forEach(function (value) {
            string += processStyleName(key) + ":" + processStyleValue(key, value) + ";";
          });
        } else {
          string += key + "{" + handleInterpolation.call(this, registered, obj[key]) + "}";
        }
      }
    }, this);
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;
var serializeStyles = function serializeStyles(registered, args) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var styles = '';
  var identifierName = '';
  args.forEach(function (interpolation, i) {
    styles += handleInterpolation.call(this, registered, interpolation);
  }, this);
  styles = styles.replace(labelPattern, function (match, p1) {
    identifierName += "-" + p1;
    return '';
  });
  var name = hashString(styles) + identifierName;
  return {
    name: name,
    styles: styles
  };
};

export { processStyleName, processStyleValue, handleInterpolation, labelPattern, serializeStyles };
